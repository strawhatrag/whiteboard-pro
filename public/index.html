<script src="/socket.io/socket.io.js"></script>
<script>
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");
  const socket = io({
    // Forces a clean WebSocket connection for better stability
    transports: ['websocket']
  });

  const colorPicker = document.getElementById("colorPicker");
  const clearMineBtn = document.getElementById("clearMineBtn");
  const clearAllBtn = document.getElementById("clearAllBtn");
  const userLabel = document.getElementById("userLabel");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  let drawing = false;
  let color = colorPicker.value;
  let myUserId = null; // Store the ID received from the server

  // Tracks which users have been 'cleared' by the clear-mine button
  // (This is a temporary, client-side only array)
  let clearedUsers = new Set();

  // ===== SESSION USER ID (PER TAB) =====
  myUserId = sessionStorage.getItem("whiteboardSessionUserId");
  if (!myUserId) {
    myUserId = Math.random().toString(36).substring(2, 7).toUpperCase();
    sessionStorage.setItem("whiteboardSessionUserId", myUserId);
  }

  // --- REGISTRATION ---
  socket.emit("register", { userId: myUserId });

  // Server sends back confirmation
  socket.on("user-info", (info) => {
    myUserId = info.userId;
    userLabel.textContent = `You: ${myUserId}`; // Should update immediately now
  });

  // NOTE: 'init-board' event is removed here as we removed the state array.

  colorPicker.addEventListener("change", (e) => {
    color = e.target.value;
  });

  // ✅ CLEAR ONLY MY STROKES (Client-side clear for this session)
  clearMineBtn.addEventListener("click", () => {
    // In a stateless environment, we can't truly clear past strokes without 
    // a persistent state, but we can prevent future strokes from being drawn.
    // For now, we clear the entire canvas and rely on a stateful server
    // to eventually resync, but since we removed state, we just trigger the 
    // broadcast and clear the local canvas.
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    socket.emit("clear-mine");
    // Mark myself as 'cleared'
    clearedUsers.add(myUserId);
  });

  // ✅ CLEAR EVERYONE
  clearAllBtn.addEventListener("click", () => {
    socket.emit("clear-all");
    clearedUsers.clear(); // Reset cleared users list
  });

  // --- DRAWING LISTENERS ---
  canvas.addEventListener("mousedown", () => (drawing = true));
  canvas.addEventListener("mouseup", () => (drawing = false));
  canvas.addEventListener("mouseleave", () => (drawing = false));
  canvas.addEventListener("mousemove", draw);

  function draw(e) {
    if (!drawing) return;

    const x = e.clientX;
    const y = e.clientY;

    const data = { x, y, color, userId: myUserId };

    // 1. Draw LOCALLY first for zero-latency feedback
    drawPoint(x, y, color);

    // 2. Send draw data to the server for broadcast to others
    socket.emit("draw", data);
  }

  // --- SERVER EVENTS ---

  // Received draw events from OTHER users
  socket.on("draw", (data) => {
    // Prevent drawing if this user was recently "cleared" locally
    if (clearedUsers.has(data.userId)) {
      return;
    }
    drawPoint(data.x, data.y, data.color);
  });

  // Server tells all clients to clear the canvas
  socket.on("clear-all", () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });

  // Server tells everyone a specific user was cleared (mostly for logging/debug)
  socket.on("clear-user-broadcast", (data) => {
    console.log(`User ${data.userId} cleared their strokes.`);
    // Note: The client cannot actually clear past strokes without state.
  });

  function drawPoint(x, y, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
</script>